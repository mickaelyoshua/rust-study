# Rust Language Tour

This document provides a concise overview of the Rust programming language, its toolchain, and core concepts.

---

## 1. Toolchain & Setup

### Developer Tools
*   **`rustc`**: The Rust compiler.
*   **Cargo**: Rust's build system and package manager.
*   **`rust-analyzer`**: A Language Server Protocol (LSP) implementation for Rust.
*   **`rustup`**: A tool to manage Rust versions and associated tools.

### Installation and Management
```bash
# Install rustup (the Rust toolchain manager)
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

# Update to the latest Rust version
rustup update

# Uninstall Rust
rustup self uninstall

# Open local documentation in your browser
rustup doc
```

---

## 2. Cargo: The Rust Package Manager

Cargo handles project creation, dependency management, building, and testing.

### Common Cargo Commands

*   `cargo new <project_name>`: Creates a new binary (executable) project.
*   `cargo new <project_name> --lib`: Creates a new library project.
*   `cargo init`: Initializes a project in the current directory.
*   `cargo build`: Compiles the project. Add `--release` for an optimized build.
*   `cargo run`: Compiles and runs the project.
*   `cargo check`: Checks the code for errors without producing an executable, which is faster than a full build.
*   `cargo update`: Updates dependencies to the latest allowed versions according to `Cargo.toml`.
*   `cargo doc --open`: Builds and opens the documentation for your project and its dependencies.

### Project Structure
A `cargo new` command generates the following:
*   `Cargo.toml`: The configuration file (manifest) for your package. It lists dependencies and metadata.
*   `src/main.rs`: The crate root for a binary project.
*   `src/lib.rs`: The crate root for a library project.
*   `Cargo.lock`: An auto-generated file that ensures builds are reproducible by locking dependency versions. Do not edit this file manually.

A **crate** is a compilation unit (a library or binary), and a **package** is one or more crates bundled together with a `Cargo.toml` manifest.

---

## 3. Fundamental Concepts

### Variables, Constants, and Shadowing
*   Variables are immutable by default. Use the `mut` keyword to make them mutable.
*   Constants (`const`) must have their type annotated and can be declared in any scope.
*   **Shadowing** allows you to declare a new variable with the same name as a previous one, effectively hiding the former.

```rust
const PI: f32 = 3.14159; // A constant

fn main() {
    let mut x = 5; // A mutable variable
    x = 6;

    let y = 5;
    let y = y + 1; // y is now shadowed and has the value 6

    {
        let y = y * 2; // y is shadowed again in this inner scope
        println!("Inner y: {y}"); // Prints "Inner y: 12"
    }

    println!("Outer y: {y}"); // Prints "Outer y: 6"
}
```

### Data Types

#### Scalar Types
*   **Integers**: `i8`, `u8`, `i32`, `u32`, `i64`, `u64`, `isize`, `usize`, etc.
*   **Floating-Point**: `f32`, `f64`.
*   **Boolean**: `bool` (`true` or `false`).
*   **Character**: `char` (a single Unicode scalar value).

#### Compound Types

**Tuples**
A fixed-size grouping of values of different types.

```rust
fn main() {
    // Creation
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // Destructuring
    let (x, y, z) = tup;

    // Access by index
    let five_hundred = tup.0;
    let six_point_four = tup.1;

    // The empty tuple `()` is called the "unit type".
}
```

**Arrays**
A fixed-size collection of values of the same type.

```rust
fn main() {
    // Creation with type annotation [type; length]
    let a: [i32; 5] = [1, 2, 3, 4, 5];

    // Creation with an initial value for all elements
    let b = [3; 5]; // [3, 3, 3, 3, 3]

    // Access by index
    let first = a[0];
}
```

### Functions
Functions are declared with the `fn` keyword. The convention is to use `snake_case` for function names.

#### Statements vs. Expressions
*   **Statements** are instructions that perform an action and do not return a value (e.g., `let x = 5;`).
*   **Expressions** evaluate to a value. A code block `{}` is an expression. The last line of a block, if it doesn't have a semicolon, is the return value of that block.

#### Return Values
Functions can return values implicitly or explicitly.
*   **Implicit Return**: The last expression in a function's body is its return value.
*   **Explicit Return**: Use the `return` keyword.

```rust
// Implicit return
fn plus_one(x: i32) -> i32 {
    x + 1
}

// Explicit return
fn plus_two(x: i32) -> i32 {
    return x + 2;
}
```

### Control Flow

#### `if` Expressions
The condition must be a `bool`. `if` is an expression and can be used in `let` statements.

```rust
fn main() {
    let number = 6;
    if number % 2 == 0 {
        println!("number is even");
    } else {
        println!("number is odd");
    }

    let result = if number > 5 { "big" } else { "small" }; // Use if as an expression
}
```

#### Loops
Rust has three kinds of loops: `loop`, `while`, and `for`.

*   **`loop`**: An infinite loop that can be broken with `break`. `break` can also return a value from the loop.
*   **`while`**: Loops as long as a condition is true.
*   **`for`**: Loops over any type that implements the `Iterator` trait.

```rust
fn main() {
    // `loop` returning a value
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    }; // result is 20

    // `for` loop over a range
    for number in (1..4).rev() { // 3, 2, 1
        println!("{number}!");
    }

    // `for` loop over an array
    let a = [10, 20, 30];
    for element in a {
        println!("the value is: {element}");
    }
}
```

---

## 4. Ownership

Ownership is Rust's most unique feature. It enables Rust to make memory safety guarantees without needing a garbage collector.

### The Rules of Ownership
1.  Each value in Rust has a variable thatâ€™s called its **owner**.
2.  There can only be **one owner at a time**.
3.  When the owner goes out of scope, the value will be **dropped**.

### Stack vs. Heap
*   **Stack**: For data with a known, fixed size. Fast LIFO (Last-In, First-Out) allocation.
*   **Heap**: For data with an unknown or dynamic size. Slower allocation; the system must find a free block of memory. The allocator returns a pointer to the memory location.

### Move Semantics
When you assign a heap-allocated value from one variable to another, Rust "moves" the value. The original variable is no longer valid. This prevents "double free" errors.

```rust
fn main() {
    // Stack data: Copy
    let x = 5;
    let y = x; // The value is copied. Both x and y are valid.

    // Heap data: Move
    let s1 = String::from("hello");
    let s2 = s1; // s1 is "moved" to s2.
                 // s1 is no longer valid to prevent double-freeing the memory.
    // println!("{s1}"); // This would cause a compile-time error.
}
```

### Clone
To perform a deep copy of heap data, use the `.clone()` method.

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // s2 is a deep copy of s1.
    println!("s1 = {s1}, s2 = {s2}"); // Both are valid.
}
```

### Ownership in Functions
Passing a value to a function follows the same move/copy rules.

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s); // s's value moves into the function...
                        // ... and is no longer valid here.

    let x = 5;
    makes_copy(x);      // x would move, but i32 is Copy, so it's copied.
                        // x is still valid here.
}

fn takes_ownership(some_string: String) { /* ... */ }
fn makes_copy(some_integer: i32) { /* ... */ }
```

---

## 5. References and Borrowing

Instead of transferring ownership, you can pass a **reference** to a value. This is called **borrowing**.

### The Rules of References
1.  At any given time, you can have *either* one mutable reference *or* any number of immutable references.
2.  References must always be valid (they cannot be dangling).

```rust
fn main() {
    let mut s1 = String::from("hello");

    // Pass an immutable reference (&T)
    let len = calculate_length(&s1);
    println!("The length of '{s1}' is {len}.");

    // Pass a mutable reference (&mut T)
    change(&mut s1);
    println!("The new string is '{s1}'.");
}

// Borrows an immutable reference
fn calculate_length(s: &String) -> usize {
    s.len()
}

// Borrows a mutable reference
fn change(s: &mut String) {
    s.push_str(", world");
}
```

### Slices
A slice is a reference to a contiguous sequence of elements in a collection.

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s
    let word = first_word(&my_string[..]);
    println!("First word: {word}");

    let my_string_literal = "hello world";

    // `first_word` works on string literals (which are slices)
    let word = first_word(my_string_literal);
    println!("First word: {word}");
}
```
*   A string slice has type `&str`.
*   String literals (`"hello"`) are string slices.
*   You can also have slices of other collections, like arrays (`&[i32]`).

---

## 6. Composite Data Types

### Structs
Structs are custom data types that group related values.

```rust
#[derive(Debug)] // Allows printing the struct for debugging
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // Create an instance
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // Access and modify data
    user1.email = String::from("anotheremail@example.com");

    // Create a new instance from an old one with struct update syntax
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1 // The remaining fields get the same values as user1
    };
    // Note: user1.username was moved to user2, so user1 is partially moved.

    println!("{:?}", user2);
}
```

### Tuple Structs
Structs without named fields. Useful for giving a tuple a distinct name and type.

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

### Methods
Methods are functions associated with a struct (or enum) and are defined in an `impl` block. Their first parameter is always `self`, `&self`, or `&mut self`.

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

// `impl` block for Rectangle
impl Rectangle {
    // A method that borrows the instance immutably
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // A method that takes another instance as a parameter
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }

    // An "associated function" (not a method because no `self`)
    // Often used as constructors.
    fn square(size: u32) -> Self {
        Self { width: size, height: size }
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("The area is {}", rect1.area());

    let sq = Rectangle::square(20);
    println!("Can rect1 hold a square of 20x20? {}", rect1.can_hold(&sq));
}
```

### Enums
Enums allow you to define a type by enumerating its possible variants.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 }, // Anonymous struct variant
    Write(String),          // Tuple variant
    ChangeColor(i32, i32, i32), // Tuple variant
}

impl Message {
    fn call(&self) {
        // method body
    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}
```

#### The `Option` Enum
The standard library provides `Option<T>` to encode a value that could be something or nothing, avoiding the use of `null`.

```rust
enum Option<T> {
    Some(T), // A value of type T is present
    None,    // No value is present
}
```
It is so common that it's in the prelude, and you can use `Some(value)` and `None` directly.

### `match` Control Flow
The `match` keyword lets you compare a value against a series of patterns and execute code based on which pattern it matches. `match` is exhaustive; you must cover every possible case.

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => { // This pattern binds `state`
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

#### `if let` and `let...else`
For cases where you only care about one pattern, `if let` is a less verbose alternative to `match`.

```rust
fn main() {
    let config_max = Some(3u8);

    // Using match
    match config_max {
        Some(max) => println!("The maximum is {max}"),
        _ => (),
    }

    // Using if let
    if let Some(max) = config_max {
        println!("The maximum is {max}");
    }
}
```
`let...else` is useful for ensuring a pattern matches, otherwise exiting a function.
```rust
fn get_state(coin: Coin) -> Option<UsState> {
    let Coin::Quarter(state) = coin else {
        return None;
    };
    Some(state)
}
```

---

## 7. Managing Projects

### Packages, Crates, and Modules
*   **Package**: One or more crates with a `Cargo.toml`.
*   **Crate**: A library or binary. The crate root is `src/lib.rs` or `src/main.rs`.
*   **Modules**: Organize code within a crate.

### Defining and Using Modules
Use `mod` to define a module, `pub` to make items public, and `use` to bring items into scope.

```rust
// In src/lib.rs
pub mod front_of_house; // Tells Rust to look for src/front_of_house.rs

use crate::front_of_house::hosting; // Bring `hosting` into scope

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

```rust
// In src/front_of_house.rs
pub mod hosting; // Tells Rust to look for src/front_of_house/hosting.rs
```

```rust
// In src/front_of_house/hosting.rs
pub fn add_to_waitlist() {}
```

### `use` Idioms
*   For functions, bring the parent module into scope: `use std::collections; collections::HashMap::new();`
*   For structs/enums, bring the full path: `use std::collections::HashMap; HashMap::new();`
*   Use `as` to rename types on import: `use std::io::Result as IoResult;`
*   Use `pub use` to re-export a name, making it part of your public API.
*   Use nested paths to clean up `use` lists: `use std::{cmp::Ordering, io};`
*   Use the glob operator `*` to bring all public items from a path into scope: `use std::collections::*;`

---

## 8. Common Collections

### Vectors
A `Vec<T>` is a resizable array that can only store values of the same type.

```rust
fn main() {
    // Create a vector
    let mut v = vec![1, 2, 3];

    // Add elements
    v.push(4);

    // Read elements
    let third: &i32 = &v[2]; // Panics if index is out of bounds
    
    match v.get(2) { // Returns Option<&T>, doesn't panic
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }

    // Iterate over elements
    for i in &v {
        println!("{i}");
    }
}
```
**Borrowing Rule**: You cannot hold an immutable reference to an item in a vector while also trying to add to the vector (which requires a mutable reference to the vector itself), because the vector might need to reallocate and move its elements in memory.

### Strings
Rust has two main string types:
*   `String`: A growable, mutable, owned, UTF-8 encoded string type. Stored on the heap.
*   `&str`: An immutable reference to a sequence of UTF-8 bytes, also known as a "string slice". String literals are `&str`.

### Hash Maps
A `HashMap<K, V>` stores a mapping from keys of type `K` to values of type `V`.

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);

    // Iterate over key-value pairs
    for (key, value) in &scores {
        println!("{key}: {value}");
    }
}
```
