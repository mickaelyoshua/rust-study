# Rust Language Tour

This document provides a concise overview of the Rust programming language, its toolchain, and core concepts.

---

## 1. Toolchain & Setup

### Developer Tools
*   **`rustc`**: The Rust compiler.
*   **Cargo**: Rust's build system and package manager.
*   **`rust-analyzer`**: A Language Server Protocol (LSP) implementation for Rust.
*   **`rustup`**: A tool to manage Rust versions and associated tools.

### Installation and Management
```bash
# Install rustup (the Rust toolchain manager)
curl --proto '=https' --tlsv1.2 https://sh.rustup.rs -sSf | sh

# Update to the latest Rust version
rustup update

# Uninstall Rust
rustup self uninstall

# Open local documentation in your browser
rustup doc
```

---

## 2. Cargo: The Rust Package Manager

Cargo handles project creation, dependency management, building, and testing.

### Common Cargo Commands

*   `cargo new <project_name>`: Creates a new binary (executable) project.
*   `cargo new <project_name> --lib`: Creates a new library project.
*   `cargo init`: Initializes a project in the current directory.
*   `cargo build`: Compiles the project. Add `--release` for an optimized build.
*   `cargo run`: Compiles and runs the project.
*   `cargo check`: Checks the code for errors without producing an executable, which is faster than a full build.
*   `cargo update`: Updates dependencies to the latest allowed versions according to `Cargo.toml`.
*   `cargo doc --open`: Builds and opens the documentation for your project and its dependencies.

### Project Structure
A `cargo new` command generates the following:
*   `Cargo.toml`: The configuration file (manifest) for your package. It lists dependencies and metadata.
*   `src/main.rs`: The crate root for a binary project.
*   `src/lib.rs`: The crate root for a library project.
*   `Cargo.lock`: An auto-generated file that ensures builds are reproducible by locking dependency versions. Do not edit this file manually.

A **crate** is a compilation unit (a library or binary), and a **package** is one or more crates bundled together with a `Cargo.toml` manifest.

---

## 3. Fundamental Concepts

### Variables, Constants, and Shadowing
*   Variables are immutable by default. Use the `mut` keyword to make them mutable.
*   Constants (`const`) must have their type annotated and can be declared in any scope.
*   **Shadowing** allows you to declare a new variable with the same name as a previous one, effectively hiding the former.

```rust
const PI: f32 = 3.14159; // A constant

fn main() {
    let mut x = 5; // A mutable variable
    x = 6;

    let y = 5;
    let y = y + 1; // y is now shadowed and has the value 6

    {
        let y = y * 2; // y is shadowed again in this inner scope
        println!("Inner y: {y}"); // Prints "Inner y: 12"
    }

    println!("Outer y: {y}"); // Prints "Outer y: 6"
}
```

### Data Types

#### Scalar Types
*   **Integers**: `i8`, `u8`, `i32`, `u32`, `i64`, `u64`, `isize`, `usize`, etc.
*   **Floating-Point**: `f32`, `f64`.
*   **Boolean**: `bool` (`true` or `false`).
*   **Character**: `char` (a single Unicode scalar value).

#### Compound Types

**Tuples**
A fixed-size grouping of values of different types.

```rust
fn main() {
    // Creation
    let tup: (i32, f64, u8) = (500, 6.4, 1);

    // Destructuring
    let (x, y, z) = tup;

    // Access by index
    let five_hundred = tup.0;
    let six_point_four = tup.1;

    // The empty tuple `()` is called the "unit type".
}
```

**Arrays**
A fixed-size collection of values of the same type.

```rust
fn main() {
    // Creation with type annotation [type; length]
    let a: [i32; 5] = [1, 2, 3, 4, 5];

    // Creation with an initial value for all elements
    let b = [3; 5]; // [3, 3, 3, 3, 3]

    // Access by index
    let first = a[0];
}
```

### Functions
Functions are declared with the `fn` keyword. The convention is to use `snake_case` for function names.

#### Statements vs. Expressions
*   **Statements** are instructions that perform an action and do not return a value (e.g., `let x = 5;`).
*   **Expressions** evaluate to a value. A code block `{}` is an expression. The last line of a block, if it doesn't have a semicolon, is the return value of that block.

#### Return Values
Functions can return values implicitly or explicitly.
*   **Implicit Return**: The last expression in a function's body is its return value.
*   **Explicit Return**: Use the `return` keyword.

```rust
// Implicit return
fn plus_one(x: i32) -> i32 {
    x + 1
}

// Explicit return
fn plus_two(x: i32) -> i32 {
    return x + 2;
}
```

### Control Flow

#### `if` Expressions
The condition must be a `bool`. `if` is an expression and can be used in `let` statements.

```rust
fn main() {
    let number = 6;
    if number % 2 == 0 {
        println!("number is even");
    } else {
        println!("number is odd");
    }

    let result = if number > 5 { "big" } else { "small" }; // Use if as an expression
}
```

#### Loops
Rust has three kinds of loops: `loop`, `while`, and `for`.

*   **`loop`**: An infinite loop that can be broken with `break`. `break` can also return a value from the loop.
*   **`while`**: Loops as long as a condition is true.
*   **`for`**: Loops over any type that implements the `Iterator` trait.

```rust
fn main() {
    // `loop` returning a value
    let mut counter = 0;
    let result = loop {
        counter += 1;
        if counter == 10 {
            break counter * 2;
        }
    }; // result is 20

    // `for` loop over a range
    for number in (1..4).rev() { // 3, 2, 1
        println!("{number}!");
    }

    // `for` loop over an array
    let a = [10, 20, 30];
    for element in a {
        println!("the value is: {element}");
    }
}
```

---

## 4. Ownership

Ownership is Rust's most unique feature. It enables Rust to make memory safety guarantees without needing a garbage collector.

### The Rules of Ownership
1.  Each value in Rust has a variable thatâ€™s called its **owner**.
2.  There can only be **one owner at a time**.
3.  When the owner goes out of scope, the value will be **dropped**.

### Stack vs. Heap
*   **Stack**: For data with a known, fixed size. Fast LIFO (Last-In, First-Out) allocation.
*   **Heap**: For data with an unknown or dynamic size. Slower allocation; the system must find a free block of memory. The allocator returns a pointer to the memory location.

### Move Semantics
When you assign a heap-allocated value from one variable to another, Rust "moves" the value. The original variable is no longer valid. This prevents "double free" errors.

```rust
fn main() {
    // Stack data: Copy
    let x = 5;
    let y = x; // The value is copied. Both x and y are valid.

    // Heap data: Move
    let s1 = String::from("hello");
    let s2 = s1; // s1 is "moved" to s2.
                 // s1 is no longer valid to prevent double-freeing the memory.
    // println!("{s1}"); // This would cause a compile-time error.
}
```

### Clone
To perform a deep copy of heap data, use the `.clone()` method.

```rust
fn main() {
    let s1 = String::from("hello");
    let s2 = s1.clone(); // s2 is a deep copy of s1.
    println!("s1 = {s1}, s2 = {s2}"); // Both are valid.
}
```

### Ownership in Functions
Passing a value to a function follows the same move/copy rules.

```rust
fn main() {
    let s = String::from("hello");
    takes_ownership(s); // s's value moves into the function...
                        // ... and is no longer valid here.

    let x = 5;
    makes_copy(x);      // x would move, but i32 is Copy, so it's copied.
                        // x is still valid here.
}

fn takes_ownership(some_string: String) { /* ... */ }
fn makes_copy(some_integer: i32) { /* ... */ }
```

---

## 5. References and Borrowing

Instead of transferring ownership, you can pass a **reference** to a value. This is called **borrowing**.

### The Rules of References
1.  At any given time, you can have *either* one mutable reference *or* any number of immutable references.
2.  References must always be valid (they cannot be dangling).

```rust
fn main() {
    let mut s1 = String::from("hello");

    // Pass an immutable reference (&T)
    let len = calculate_length(&s1);
    println!("The length of '{s1}' is {len}.");

    // Pass a mutable reference (&mut T)
    change(&mut s1);
    println!("The new string is '{s1}'.");
}

// Borrows an immutable reference
fn calculate_length(s: &String) -> usize {
    s.len()
}

// Borrows a mutable reference
fn change(s: &mut String) {
    s.push_str(", world");
}
```

### Slices
A slice is a reference to a contiguous sequence of elements in a collection.

```rust
fn first_word(s: &str) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[0..i];
        }
    }

    &s[..]
}

fn main() {
    let my_string = String::from("hello world");

    // `first_word` works on slices of `String`s
    let word = first_word(&my_string[..]);
    println!("First word: {word}");

    let my_string_literal = "hello world";

    // `first_word` works on string literals (which are slices)
    let word = first_word(my_string_literal);
    println!("First word: {word}");
}
```
*   A string slice has type `&str`.
*   String literals (`"hello"`) are string slices.
*   You can also have slices of other collections, like arrays (`&[i32]`).

---

## 6. Composite Data Types

### Structs
Structs are custom data types that group related values.

```rust
#[derive(Debug)] // Allows printing the struct for debugging
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}

fn main() {
    // Create an instance
    let mut user1 = User {
        email: String::from("someone@example.com"),
        username: String::from("someusername123"),
        active: true,
        sign_in_count: 1,
    };

    // Access and modify data
    user1.email = String::from("anotheremail@example.com");

    // Create a new instance from an old one with struct update syntax
    let user2 = User {
        email: String::from("another@example.com"),
        ..user1 // The remaining fields get the same values as user1
    };
    // Note: user1.username was moved to user2, so user1 is partially moved.

    println!("{user2:?}");
}
```

### Tuple Structs
Structs without named fields. Useful for giving a tuple a distinct name and type.

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

let black = Color(0, 0, 0);
let origin = Point(0, 0, 0);
```

### Methods
Methods are functions associated with a struct (or enum) and are defined in an `impl` block. Their first parameter is always `self`, `&self`, or `&mut self`.

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

// `impl` block for Rectangle
impl Rectangle {
    // A method that borrows the instance immutably
    fn area(&self) -> u32 {
        self.width * self.height
    }

    // A method that takes another instance as a parameter
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }

    // An "associated function" (not a method because no `self`)
    // Often used as constructors.
    fn square(size: u32) -> Self {
        Self { width: size, height: size }
    }
}

fn main() {
    let rect1 = Rectangle { width: 30, height: 50 };
    println!("The area is {}", rect1.area());

    let sq = Rectangle::square(20);
    println!("Can rect1 hold a square of 20x20? {}", rect1.can_hold(&sq));
}
```

### Enums
Enums allow you to define a type by enumerating its possible variants.

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 }, // Anonymous struct variant
    Write(String),          // Tuple variant
    ChangeColor(i32, i32, i32), // Tuple variant
}

impl Message {
    fn call(&self) {
        // method body
    }
}

fn main() {
    let m = Message::Write(String::from("hello"));
    m.call();
}
```

#### The `Option` Enum
The standard library provides `Option<T>` to encode a value that could be something or nothing, avoiding the use of `null`.

```rust
enum Option<T> {
    Some(T), // A value of type T is present
    None,    // No value is present
}
```
It is so common that it's in the prelude, and you can use `Some(value)` and `None` directly.

### `match` Control Flow
The `match` keyword lets you compare a value against a series of patterns and execute code based on which pattern it matches. `match` is exhaustive; you must cover every possible case.

```rust
fn value_in_cents(coin: Coin) -> u8 {
    match coin {
        Coin::Penny => 1,
        Coin::Nickel => 5,
        Coin::Dime => 10,
        Coin::Quarter(state) => { // This pattern binds `state`
            println!("State quarter from {:?}!", state);
            25
        }
    }
}
```

#### `if let` and `let...else`
For cases where you only care about one pattern, `if let` is a less verbose alternative to `match`.

```rust
fn main() {
    let config_max = Some(3u8);

    // Using match
    match config_max {
        Some(max) => println!("The maximum is {max}"),
        _ => (),
    }

    // Using if let
    if let Some(max) = config_max {
        println!("The maximum is {max}");
    }
}
```
`let...else` is useful for ensuring a pattern matches, otherwise exiting a function.
```rust
fn get_state(coin: Coin) -> Option<UsState> {
    let Coin::Quarter(state) = coin else {
        return None;
    };
    Some(state)
}
```

---

## 7. Error Handling

Rust distinguishes between two types of errors:
*   **Recoverable errors** are those that can be reasonably expected, like a file not being found. These are handled with the `Result<T, E>` enum.
*   **Unrecoverable errors** are programming errors, like trying to access an index beyond an array's bounds. These cause a `panic!`.

### `Result<T, E>` for Recoverable Errors
The `Result` enum has two variants: `Ok(T)` for success and `Err(E)` for failure.

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {:?}", error),
    };
}
```

### The `?` Operator for Propagating Errors
The `?` operator provides a concise way to propagate errors. If the value of a `Result` is `Ok`, the value inside is returned. If it's `Err`, the `Err` is returned from the whole function. It can only be used in functions that return a `Result` or `Option`.

```rust
use std::fs::File;
use std::io::{self, Read};

// Manually propagating with match
fn read_username_from_file_long() -> Result<String, io::Error> {
    let mut username_file = match File::open("hello.txt") {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();
    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}

// Idiomatic propagation with `?`
fn read_username_from_file_short() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?;
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```
**Best Practice**: Use `Result` for any error that could occur at runtime and should be handled. Use `panic!` for programming errors or states that should be impossible.

---

## 8. Generics, Traits, and Lifetimes

These features allow for writing abstract, reusable, and safe code.

### Generics (`<T>`)
Generics allow you to write code that operates on abstract data types, avoiding duplication.

```rust
// A generic function `largest` that works on any type `T`
// that implements the `PartialOrd` trait (for comparison).
fn largest<T: PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];
    for item in list {
        if item > largest {
            largest = item;
        }
    }
    largest
}

// A generic struct `Point` that can hold any type `T`.
struct Point<T> {
    x: T,
    y: T,
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];
    println!("The largest number is {}", largest(&number_list));

    let char_list = vec!['y', 'm', 'a', 'q'];
    println!("The largest char is {}", largest(&char_list));
    
    let integer_point = Point { x: 5, y: 10 };
    let float_point = Point { x: 1.0, y: 4.0 };
}
```

### Traits: Defining Shared Behavior
A trait defines a set of methods that a type must implement, similar to an interface in other languages.

```rust
// Define a trait
pub trait Summary {
    fn summarize(&self) -> String;
}

// Implement the trait for a type
pub struct NewsArticle {
    pub headline: String,
    pub author: String,
}
impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {}", self.headline, self.author)
    }
}

// Use the trait as a parameter (a "trait bound")
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

fn main() {
    let article = NewsArticle {
        headline: String::from("Penguins win the Stanley Cup!"),
        author: String::from("Iceburgh"),
    };
    notify(&article);
}
```

### Lifetimes (`<'a>`)
Lifetimes are a way of telling the Rust compiler how long references are valid, ensuring they don't outlive the data they point to (preventing dangling references).

In many cases, the compiler can infer lifetimes (lifetime elision). But when a function's return type is a reference, its lifetime must be tied to the lifetime of one of the input references.

```rust
// This function's return value will have the same lifetime `'a`
// as the shorter of the two input slices `x` and `y`.
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() {
        x
    } else {
        y
    }
}

fn main() {
    let string1 = String::from("long string is long");
    let result;
    {
        let string2 = String::from("xyz");
        result = longest(string1.as_str(), string2.as_str());
        println!("The longest string is {}", result); // Works here
    }
    // println!("The longest string is {}", result); // Compile error! `string2` is out of scope.
}
```

---

## 9. Closures and Iterators

### Closures
Closures are anonymous functions you can save in a variable or pass as arguments. They can capture values from the scope in which theyâ€™re defined.

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let intensity = 10;
    let random_number = 7;

    // A closure that captures `intensity` and `random_number` from its environment.
    let expensive_closure = |num: u32| -> u32 {
        println!("calculating slowly...");
        thread::sleep(Duration::from_secs(2));
        num
    };

    // Example of using the closure
    let result = expensive_closure(intensity);
    println!("Result: {}", result);
}
```

### Iterators
Iterators allow you to perform tasks on a sequence of items. They are lazy, meaning they have no effect until you call a "consuming" method.

*   **Iterator adaptors**: Methods that transform an iterator into a different kind of iterator (e.g., `map`, `filter`).
*   **Consuming adaptors**: Methods that use up the iterator (e.g., `sum`, `collect`).

```rust
fn main() {
    let v1 = vec![1, 2, 3];

    // `iter()` creates an iterator.
    // `map` is an adaptor that creates a new iterator by applying a closure.
    // `collect` is a consumer that gathers the results into a collection.
    let v2: Vec<_> = v1.iter().map(|x| x + 1).collect();

    assert_eq!(v2, vec![2, 3, 4]);
}
```

---

## 10. Smart Pointers

Smart pointers are data structures that act like pointers but also have additional metadata and capabilities, such as automatic memory management.

*   **`Box<T>`**: For allocating values on the heap. Use when you have a large amount of data and want to transfer ownership, or for creating recursive types (e.g., a list where an enum variant contains another list).
*   **`Rc<T>` (Reference Counting)**: For enabling multiple ownership of a value. It keeps track of the number of references to a value and cleans it up only when there are zero references left. **This is for single-threaded scenarios only.**
*   **`RefCell<T>` (Interior Mutability)**: Allows you to mutate data even when there are immutable references to it. It enforces the borrowing rules at *runtime* instead of compile time. If the rules are violated, your program will `panic`.

```rust
use std::rc::Rc;
use std::cell::RefCell;

// Example of Rc<T> for multiple ownership
enum List {
    Cons(i32, Rc<List>),
    Nil,
}

// Example of RefCell<T> for interior mutability
let value = Rc::new(RefCell::new(5));
let a = Rc::clone(&value);
let b = Rc::clone(&value);

*a.borrow_mut() += 10; // Mutate through an immutable reference

println!("b after mutation: {:?}", b.borrow()); // Prints 15
```

---

## 11. Managing Projects

### Packages, Crates, and Modules
*   **Package**: One or more crates with a `Cargo.toml`.
*   **Crate**: A library or binary. The crate root is `src/lib.rs` or `src/main.rs`.
*   **Modules**: Organize code within a crate.

### Defining and Using Modules
Use `mod` to define a module, `pub` to make items public, and `use` to bring items into scope.

```rust
// In src/lib.rs
pub mod front_of_house; // Tells Rust to look for src/front_of_house.rs

use crate::front_of_house::hosting; // Bring `hosting` into scope

pub fn eat_at_restaurant() {
    hosting::add_to_waitlist();
}
```

```rust
// In src/front_of_house.rs
pub mod hosting; // Tells Rust to look for src/front_of_house/hosting.rs
```

```rust
// In src/front_of_house/hosting.rs
pub fn add_to_waitlist() {}
```

### `use` Idioms
*   For functions, bring the parent module into scope: `use std::collections; collections::HashMap::new();`
*   For structs/enums, bring the full path: `use std::collections::HashMap; HashMap::new();`
*   Use `as` to rename types on import: `use std::io::Result as IoResult;`
*   Use `pub use` to re-export a name, making it part of your public API.
*   Use nested paths to clean up `use` lists: `use std::{cmp::Ordering, io};`
*   Use the glob operator `*` to bring all public items from a path into scope: `use std::collections::*;`

---

## 12. Common Collections

### Vectors
A `Vec<T>` is a resizable array that can only store values of the same type.

```rust
fn main() {
    // Create a vector
    let mut v = vec![1, 2, 3];

    // Add elements
    v.push(4);

    // Read elements
    let third: &i32 = &v[2]; // Panics if index is out of bounds
    
    match v.get(2) { // Returns Option<&T>, doesn't panic
        Some(third) => println!("The third element is {third}"),
        None => println!("There is no third element."),
    }

    // Iterate over elements
    for i in &v {
        println!("{i}");
    }
}
```
**Borrowing Rule**: You cannot hold an immutable reference to an item in a vector while also trying to add to the vector (which requires a mutable reference to the vector itself), because the vector might need to reallocate and move its elements in memory.

### Strings
Rust has two main string types:
*   `String`: A growable, mutable, owned, UTF-8 encoded string type. Stored on the heap.
*   `&str`: An immutable reference to a sequence of UTF-8 bytes, also known as a "string slice". String literals are `&str`.

### Hash Maps
A `HashMap<K, V>` stores a mapping from keys of type `K` to values of type `V`.

```rust
use std::collections::HashMap;

fn main() {
    let mut scores = HashMap::new();

    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    let team_name = String::from("Blue");
    let score = scores.get(&team_name).copied().unwrap_or(0);

    // Iterate over key-value pairs
    for (key, value) in &scores {
        println!("{key}: {value}");
    }
}
```

---

## 13. Fearless Concurrency

Rust's ownership and type system provide strong guarantees that allow you to write concurrent code free of many common bugs, like race conditions, at compile time.

*   **Concurrency**: When different parts of a program execute independently.
*   **Parallelism**: When different parts of a program execute at the same time.

### Using Threads to Run Code Simultaneously

You can create a new thread with `thread::spawn`. The main thread must wait for the spawned thread to finish using a `JoinHandle` to prevent it from being terminated prematurely.

The `move` keyword is often used with the closure passed to `thread::spawn` to force the closure to take ownership of the values it uses from the environment.

```rust
use std::thread;
use std::time::Duration;

fn main() {
    let handle = thread::spawn(|| {
        for i in 1..10 {
            println!("hi number {} from the spawned thread!", i);
            thread::sleep(Duration::from_millis(1));
        }
    });

    for i in 1..5 {
        println!("hi number {} from the main thread!", i);
        thread::sleep(Duration::from_millis(1));
    }

    // Block the main thread until the spawned thread finishes
    handle.join().unwrap();
}
```

### Message Passing with Channels

Channels are a safe way to send data between threads, avoiding the risks of shared memory. Rust's implementation follows the principle: *"Do not communicate by sharing memory; instead, share memory by communicating."*

A channel has a transmitter (`tx`) and a receiver (`rx`).

```rust
use std::sync::mpsc; // multiple producer, single consumer
use std::thread;

fn main() {
    let (tx, rx) = mpsc::channel();

    let tx_clone = tx.clone(); // Clone the transmitter to use in another thread

    // Spawn a thread that sends messages
    thread::spawn(move || {
        let vals = vec![
            String::from("hi"),
            String::from("from"),
            String::from("the"),
            String::from("thread"),
        ];
        for val in vals {
            tx.send(val).unwrap();
        }
    });
    
    // Spawn another thread sending messages
    thread::spawn(move || {
        let vals = vec![
            String::from("more"),
            String::from("messages"),
            String::from("for"),
            String::from("you"),
        ];
        for val in vals {
            tx_clone.send(val).unwrap();
        }
    });

    // The receiver can be used as an iterator in the main thread
    for received in rx {
        println!("Got: {}", received);
    }
}
```

### Shared-State Concurrency with `Mutex<T>`

While message passing is a great approach, you can also share memory between threads. A `Mutex<T>` (mutual exclusion) is a smart pointer that ensures only one thread can access the data at any given time.

To access the data, a thread must first acquire the mutex's **lock**. The lock is automatically released when the `MutexGuard` (returned by `lock()`) goes out of scope.

### Sharing a `Mutex<T>` Between Multiple Threads

To share ownership of a `Mutex<T>` across multiple threads, we use the smart pointer `Arc<T>` (Atomically Reference Counted). It is the thread-safe equivalent of `Rc<T>`.

The pattern `Arc<Mutex<T>>` is very common in Rust for sharing mutable state between threads.

```rust
use std::sync::{Arc, Mutex};
use std::thread;

fn main() {
    // Create a counter inside an atomically reference-counted Mutex.
    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        // Clone the Arc to increase the reference count for each thread
        let counter = Arc::clone(&counter);
        
        let handle = thread::spawn(move || {
            // Acquire the lock. This blocks until the lock is available.
            let mut num = counter.lock().unwrap();
            
            *num += 1;
            // The lock is automatically released when `num` goes out of scope here.
        });
        handles.push(handle);
    }

    // Wait for all the threads to finish.
    for handle in handles {
        handle.join().unwrap();
    }

    // Print the final result.
    println!("Result: {}", *counter.lock().unwrap());
}
```

### The `Send` and `Sync` Traits

These two marker traits are crucial to Rust's concurrency safety:
*   **`Send`**: A type `T` is `Send` if it is safe to transfer its ownership to another thread. Most types are `Send`. `Arc<T>` is `Send` if `T` is `Send` and `Sync`.
*   **`Sync`**: A type `T` is `Sync` if it is safe to be referenced from multiple threads simultaneously (`&T` is `Send`). `Mutex<T>` is `Sync`.

The compiler enforces that only types that are `Send` and `Sync` can be shared between threads, preventing data races at compile time. You rarely need to implement these traits manually.
